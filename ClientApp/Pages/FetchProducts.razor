@page "/fetchproducts"
@using System.Net.Http.Json
@using System.Text.Json
@inject HttpClient Http
@inject ILogger<FetchProducts> Logger

<h3>Product List</h3>

<ul>
   @if (products != null && products.Length > 0)
    {
        foreach (var product in products)
        {
            <li>@product.Name - $@product.Price</li>
        }
    }
    else if (products != null && products.Length == 0)
    {
        <li>No products available.</li>
    }
    else
    {
        <li>Loading...</li>
    }
</ul>

@code {
    private Product[]? products;
    private static readonly TimeSpan RequestTimeout = TimeSpan.FromSeconds(10);
    private string apiUrl = "http://localhost:5104/api/productlist";

    protected override async Task OnInitializedAsync()
    {
        using var cts = new CancellationTokenSource(RequestTimeout);
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };

        try
        {
            Logger?.LogInformation("Calling API: Url={Url}", apiUrl);

            // Deserializa directamente usando la URL absoluta y el CancellationToken
            products = await Http.GetFromJsonAsync<Product[]>(apiUrl, options, cts.Token)
                       ?? Array.Empty<Product>();

            if (products.Length == 0)
            {
                Logger?.LogInformation("API returned an empty product list.");
            }
        }
        catch (OperationCanceledException) when (cts.IsCancellationRequested)
        {
            // El CancellationTokenSource expiró: la petición se canceló por timeout.
            // Aquí registramos la situación y devolvemos un arreglo vacío para no romper la UI.
            Logger?.LogWarning("Request to API timed out after {Timeout}s", RequestTimeout.TotalSeconds);
            products = Array.Empty<Product>();
        }
        catch (NotSupportedException ex)
        {
            // El contenido devuelto por la API tiene un formato no soportado (p. ej. no es JSON).
            // Registrar el error ayuda a depurar problemas de contrato entre cliente y servidor.
            Logger?.LogError(ex, "API returned content in an unsupported format.");
            products = Array.Empty<Product>();
        }
        catch (JsonException ex)
        {
            // Se produjo un error al deserializar el JSON (JSON mal formado o estructura inesperada).
            // Registrar el detalle permite revisar el payload recibido y ajustar modelos/serialización.
            Logger?.LogError(ex, "Failed to deserialize API response as Product[].");
            products = Array.Empty<Product>();
        }
        catch (HttpRequestException ex)
        {
            // Errores relacionados con la petición HTTP (red, DNS, conexión rechazada, etc.).
            // Útil para distinguir problemas de red frente a errores de contenido o lógica.
            Logger?.LogError(ex, "HTTP request failed while fetching products.");
            products = Array.Empty<Product>();
        }
        catch (Exception ex)
        {
            // Captura cualquier excepción inesperada no contemplada por los catches anteriores.
            // Registrar la excepción permite identificar casos borde y corregir la lógica.
            Logger?.LogError(ex, "Unexpected error fetching products.");
            products = Array.Empty<Product>();
        }
    }

    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public double Price { get; set; }
        public int Stock { get; set; }
    }
}